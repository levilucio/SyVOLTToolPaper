In this section we present an evaluation of our contract-proving technique on the mbeddr case study. In particular, we are interested in the following
research questions:

\begin{itemize}
\item RQ1: How much time and memory does the contract prover use to prove the contracts?
\item RQ2: Does slicing the transformation for a contract produce the same result as verification on the whole transformation?
\item RQ3: In the cases where a contract fails, how can we assist the user in understanding why?
\end{itemize}

In order to minimize the time required to prove the contracts, slicing was performed. This technique selects only those rules in the transformation that are required for verification of that contract. More information is presented in~\cite{Oakes2016}.

\subsection{Measures}

To objectively answer our defined research questions, contract prover experiments were conducted for all contracts. For each case study, the success of our contract prover rests on whether the contracts we have indicated hold or do not hold on all path conditions (as appropriate).

The following information was collected during the contract proving process:

\begin{itemize}
\item Number of rules in each transformation
\item Number of path conditions produced by the contract prover
\item Time required in order to generate all path conditions
\item Number of contracts to be proved on the case study
\item Time required to prove the contracts
\item Maximum memory usage required by the contract prover
\end{itemize}


The experiments were run on a 2013 Macbook Air with an Intel Core i5-4250U and 8 GB of RAM, running on Arch Linux and Python 3.5.1. Both the path condition construction and contract proving processes were parallelized amongst four threads. Each experiment was conducted at least five times, with results averaged. Timing information was obtained by using the Python timing package \textit{time}. Memory information was obtained using the \texttt{/usr/bin/time} command. Note that the memory usage information will also record the space overhead required by the Python interpreter.

All the artifacts used for our experiments can be found on our website~\cite{NEW WEBSITE NEEDED}.


\subsection{Results}


Table~\ref{table:performance} shows the performance results for proving the contracts on our case studies. We shall now discuss these results in the context of our research questions.

\begin{table*}[tb]
\caption{Performance results}
\label{table:performance}
\begin{tabular}{l | p{2.5cm}| | r |r || r |r || r}
 &  \textbf{DSLTrans Rules}&  \textbf{Path Conds.}  & \textbf{Time (s)} & \textbf{Contracts} & \textbf{Time (s)}& \textbf{Memory}\\
 & \centering \textbf{Rules}&  \textbf{Generated}&  &  \textbf{Proved}& & \textbf{(MB)} \\ \hline\hline
Full Transformation & \centering 47 & - & - & - & -& -\\\hline
Sliced Contract 1 & \centering 25 & 6064	& 51.14 & 1	& 19.92 & 158\\\hline
Sliced Contract 2& \centering 9 & 13 & 0.18 & 9 & 0.15 & 58\\
\end{tabular}
\newline

%\vspace{-0.25in}
\end{table*}


\subsubsection{RQ1: Performance}

As seen in~\cite{Oakes2016}, our prover scales well to reasonably-sized transformations. In that work, transformation up to 19 rules were verified. Even though our technique is exhaustive, our
approach takes relatively short amounts of time to prove contracts. \cite{Selim2014} demonstrates that our prover is substantially faster than similar approaches based on SAT solvers.

\subsubsection{RQ2: Slicing}

\subsubsection{RQ3: Explaining Contract Failure}

Name:AssignmentInstance
	Num Succeeded Contracts: 40
	Num Failed Contracts: 40
	
Good rules: (Rules in success set and not failure set)
['Hlayer1rule10']


Bad rules: (Rules common to all in failure set)
[]

Contract requires elements of type:


Contract requires links of type:

	AtomicComponent - directLink\_S ( return attr\_value  "contents")  - RequiredPort
	
	StructDeclaration - directLink\_T ( return attr\_value  "members")  - Member


