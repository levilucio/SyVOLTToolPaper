This section will describe our proving technique, as well as present an overview of the principles and major design of the SyVOLT tool which implements this technique.

\subsection{Proving Technique}
This section will describe the operation of our contract prover such that contracts are proven on all executions of a
DSLTrans transformation.

The contract prover we describe here is the engine of
the SyVOLT tool, which can currently be used to develop and verify DSLTrans transformations within the Eclipse
environment~\cite{Lucio2015,syvoltTool,syvoltVideo}. Examples of contracts we prove are also presented, along with a brief discussion of the expressibility of the contract language.

\subsection{Contract Proving Overview}

Given a transformation written in the DSLTrans transformation language, our
contract proving technique can prove whether pre-\slash post-condition contracts will hold or
not hold on all executions of the transformation. If a contract holds, then whenever the pre-condition of the contract matches over an input model, then the post-condition of the contract will match over the corresponding output model.

  \begin{figure}[ht]
     \begin{center}
       \includegraphics[width=0.36\textwidth]{figures/FamToPersons/Pos_FourMembers.png}
       \caption{A contract to verify that two \emph{Woman} and two \emph{Man} elements are produced from the corresponding \emph{Members}}
       \label{fig:familyProp}
     \end{center}
     \vspace{-0.15in}
   \end{figure}

  For example, Figure~\ref{fig:familyProp} describes a contract to be proved over all transformation executions for the extended \FTP transformation. An informal statement for this contract is:
  \textit{`an input family with a father, mother, son and daughter should always produce
  two men and two women in the output community'}. Note that we employ backward links as part of the contract language, where as they are used to require that the output elements be
  generated from the attached input elements, similar to their use in DSLTrans rules. Our contract prover is then
  able to prove whether or not this contract will hold for all transformation executions, and produce any counter-examples if they occur. Further examples of contracts are found in Section~\ref{subsubsec:contract_examples}.


 Contracts are proved through a process that first symbolically constructs all
 possible executions of the transformation, producing a set of \emph{path conditions}. Each path condition represents the execution of a set of transformation rules, by containing the input and output elements which are produced by the execution of those transformation rules.

 For example, the path condition in Figure~\ref{fig:pc_first} represents the execution of three rules in the transformation. This representation includes the input and output elements that will be present in the input and output models if these three rules execute. The set of path conditions produced by the prover will therefore partition the set of valid executions of the transformation, where each execution is an input/output model pair. This technique was first proposed in~\cite{Lucio2010} and further detailed in~\cite{Lucio2014}.

   \begin{figure}[t]
     \begin{center}
       \includegraphics[width=0.45\textwidth]{figures/prover/pc}
       \caption{An example path condition representing the execution of three rules}
       \label{fig:pc_first}
     \end{center}
     \vspace{-0.20in}
   \end{figure}



 Pre-/post-condition contracts form an implication, which needs to be checked
 for each path condition that has been generated by the proving algorithm. In broad
 terms, a contract holds on a path condition if either the contract's
 pre-condition elements cannot be found in the path condition, or the contract's pre-condition
 together with its post-condition can be found in the path condition. The contract
 does not hold on the path condition if its pre-condition can be
 found in the path condition but its post-condition cannot. Finally, a contract
 holds for a transformation if it holds for all of its generated path conditions.

 Contracts are formally described in~\cite{Lucio2014}, while extensive discussion of the contract language is found in the PhD thesis of Gehan Selim~\cite{Selim2015}. Section~\ref{subsubsec:contract_examples} and Section~\ref{subsubsec:contract_results} present further contract examples, while Section~\ref{subsubsec:contract_expressiveness} briefly discusses the expressiveness of the contract language.

\subsection{Path Condition Creation}
\label{subsec:contract_prover}

As described in \cite{Lucio2015}, our contract prover constructs all artifacts used for contract proof through matching and rewriting of typed graphs. Therefore, the first step for the contract proving process is to create T-Core matcher and rewriter primitives from each of the rules
in the DSLTrans transformation~\cite{Syriani2013}. These model transformation primitives are at the core of our prover, allowing us to
reason about how rules could overlap with each other during transformation
execution, and to perform the graph rewriting necessary for our
technique.

Note that this use of reasoning about the transformation under study as explicit graphs is in opposition to other approaches in the literature, where the transformation specifications are translated into a SAT solver or theorem prover, and then the proving mechanisms for those tools are used. A further discussion of our approach versus that in the literature can be found in~\cite{Selim2015}.

In order to fully reason about all input models to a transformation, our contract prover creates a set of artifacts that represent all
possible executions of the transformation. These artifacts are created by
symbolically executing all rules in the transformation, taking into account
rule overlapping and dependencies between rules. The rule combinations that are
created are termed \textit{path conditions}.

For example, the first path
condition could represent the case where no rules in the transformation execute.
The next path condition is the case where only the first rule executes, the next
is where only the second rule executes, and a fourth path condition is where
both the two rules execute.

Note that in our path condition creation process, we
only consider one execution of each rule. That is, either a rule does not
execute (and does not appear in the path condition), or we assume that it executes some number of times (and the rule appears once). This restriction is due to our abstraction, where we symbolically represent
many executions of the same rule by the rule being present only once in each path
condition. This abstraction is necessary for analysis purposes, as the infinite number of transformation executions must be covered by a finite number of path conditions. Note that this abstraction is possible because of the
monotonicity of a DSLTrans transformation: a rule can only add elements to the
output model of a DSLTrans transformation, but never remove them.

As the transformation is made of layers, the symbolic execution process moves
through each layer and determines how rules may interact with each other. Unlike generating the powerset of all rules, these
rule interactions may in fact decrease the number of path conditions generated
by the prover as certain combinations of rules are proven infeasible.

For example, consider a rule R1 which matches on an \textit{A} element, and a
rule R2 which matches on an \textit{A} element connected to a \textit{B}
element. During an execution of the transformation, it would be impossible for R2 to execute without R1 also executing, as the match graph of R1 is a subset of the match graph of R2. Therefore, the rule R1 is `subsumed' by the rule R2. Our prover is able to detect these subsumption interactions and resolve them in a step just prior to path condition generation. This lowers the number of path conditions created by disallowing certain rule combinations, as further discussed in~\cite{Selim2014}.

As well, DSLTrans rules can also define \textit{backward links}, as described for the extended \FTP transformation in Section~\ref{sec:ATL_DSLTrans}. Recall that these backward links make dependencies on elements created by earlier rules. Specifically, these backward links require that the connected element in the
apply part of the rule was created from the connected element in the match part of the rule, by matching over traceability links created during the execution of the transformation. This functionality is therefore similar to the implicit binding step present in ATL, as discussed in Section~\ref{sec:ATL_DSLTrans} under the title \textit{Generic Semantics for Step 2}. During path condition construction, these backward link dependencies prevent some rules from executing, further decreasing the rule combinations possible.






 